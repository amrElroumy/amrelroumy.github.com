<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Amr Elroumy's Blog (Concurrency)</title><link>http://amrelroumy.github.io</link><description>Science, Code, Personal Encounters &amp; and other random stuff</description><lastBuildDate>Thu, 11 Jul 2013 14:00:18 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Concurrency in C++ [Prologue]</title><link>http://amrelroumy.github.io/posts/2013/06/concurrency-in-cpp-prologue.html</link><description>&lt;h3&gt;First things first&lt;/h3&gt;
&lt;p&gt;The purpose of these posts is to explore the newly release thread-aware memory model supported by the new C++11 standard. But before we get our hacking on, we'll need to get some terminology out of our way. These terminology can be divided into a couple of questions that we'll answer in this post&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What is the difference between concurrency and parallelism?&lt;/li&gt;
&lt;li&gt;What are threads? And what is the difference between threads and processes?&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;What is the difference between concurrency and parallelism?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Parallelism&lt;/strong&gt;: When we execute several computations in parallel, e.g. multiple tasks are executing code simultaneously (at the same instant) on multi-processor/multi-core/distributed systems with the goal of hopefully running faster than it would on a single processor.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Parallel Execution" src="/2013/06/parallel-execution.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Concurrency&lt;/strong&gt;: Is a more generalized term than parallelism; where multiple tasks are making progress in a specific interval. Meaning that their executions overlap, but that doesn't necessarily mean that they are executing at the same instant.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Concurrent Execution" src="/2013/06/concurrent-execution.jpg"&gt;&lt;/p&gt;
&lt;p&gt;A great importance of concurrency is its role in making computer software more usable, example when running software that uses an MDI (Multiple Document Interface) or a TDI (Tabbed Document Interface) like a word processor or a browser on a single-core processor, you get to operate on several documents and interact properly with the GUI without any lagging or sluggishness. Or having a program that connects to a database, retrieves data from it while still being able to handle the user's interactions. This can't be achieved if each task gets to complete all of its work before relinquishing the processor control. One way to achieve this scenarios would require using time-slicing, where the processor's time is divided into slices to be shared between a number of tasks and each task runs until its time is over then an interrupt is made to switch (context switch) to another task, giving the illusion that tasks are running in parallel. This mode of operation can also be referred to as preemptive multitasking. You could also &lt;a href="http://concur.rspace.googlecode.com/hg/talk/concur.html"&gt;check Rob Pike's demo about the difference between Concurrency and Parallelism&lt;/a&gt; (slide 14:30)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Having established the difference between concurrency and parallelism we can now move on to another concept which is threads. &lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;What are threads? &lt;br&gt; And what is the difference between threads and processes?&lt;/h3&gt;
&lt;p&gt;Before we answer this question, we'll try to use an &lt;a href="http://www.qnx.com/developers/docs/6.4.0/neutrino/getting_started/s1_procs.html#Fundamentals"&gt;analogy&lt;/a&gt; that might make things easier to grasp.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;A process is like a house&lt;/h4&gt;
&lt;p&gt;A house is really a container, with certain attributes (such as the amount of floor space, the number of bedrooms, and so on).&lt;/p&gt;
&lt;p&gt;If you look at it that way, the house really doesn't actively do anything on its own -- it's a passive object. This is effectively what a process is. We'll explore this shortly.&lt;/p&gt;
&lt;h4&gt;Threads are like the occupants&lt;/h4&gt;
&lt;p&gt;The people living in the house are the active objects -- they're the ones using the various rooms, watching TV, cooking, taking showers, and so on. We'll soon see that's how threads behave.&lt;/p&gt;
&lt;h4&gt;You could be living by yourself (Single-threaded)&lt;/h4&gt;
&lt;p&gt;If you've ever lived on your own, then you know what this is like -- you know that you can do anything you want in the house at any time, because there's nobody else in the house. If you want to turn on the stereo, use the wash-room, have dinner -- whatever -- you just go ahead and do it.&lt;/p&gt;
&lt;h4&gt;You can have some company with you (Multi-threaded)&lt;/h4&gt;
&lt;p&gt;Things change dramatically when you add another person into the house. Let's say you get married, so now you have a spouse living there too. You can't just march into the wash-room at any given point; you need to check first to make sure your spouse isn't in there!&lt;/p&gt;
&lt;p&gt;If you have two responsible adults living in a house, generally you can be reasonably lax about "security" -- you know that the other adult will respect your space, won't try to set the kitchen on fire (deliberately!), and so on.&lt;/p&gt;
&lt;p&gt;Now, throw a few kids into the mix and suddenly things get a lot more interesting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Threads represent the smallest sequence of execution in a program that can be managed independently by the OS, meaning that in terms of the time-slicing approach we've referred to earlier, the slice can't be assigned to anything more granular than threads. &lt;/p&gt;
&lt;p&gt;Threads hold tasks like loading a document and updating the UI which are interleaved by the scheduler to run concurrently.&lt;/p&gt;
&lt;p&gt;After examining the previous analogy we can say that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A single instance of a program constitutes a running process which in turn may contain a single main thread or multiple running threads.&lt;/li&gt;
&lt;li&gt;Threads of the same process run in a shared memory space, while each process on the other hand have its own memory space. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on this mode of operation, there are some consequences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Threads are more easy to instantiate than processes because they don't require the allocation of a new address space like processes.&lt;/li&gt;
&lt;li&gt;Because processes are independent of each other, they require some sort of channel in order to communicate with each other e.g. message passing used in MPI&lt;/li&gt;
&lt;li&gt;Threads on the other hand don't suffer from lack of communication because they share the same memory, consequently synchronization between the threads is required to make sure that one thread won't tamper with a shared resource e.g. a data structure (the wash-room from our analogy) while another thread is operating on it. We'll talk later about the methods for accomplishing synchronization between threads.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When do we divide tasks into threads and when do we spawn several processes to run them is mainly up to the programmer to decide how his software is going to behave. To illustrate, we'll talk about a ubiquitous tool in our present; browsers.
A few years ago when we wanted to operate on several tabs on a browser that supported &lt;strong&gt;TDI&lt;/strong&gt;, the application's process  spawned a separate child thread for each tab. Around 2008, Chromium started using a different model "multi-process architecture" where separate processes were spawned for managing tabs, web apps and plug-ins.&lt;/p&gt;
&lt;p&gt;The reasons behind the approach that was taken in Chromium in putting web apps and plug-ins in separate processes from the browser itself can be found &lt;a href="http://blog.chromium.org/2008/09/multi-process-architecture.html"&gt;in this post explaining the multi-process architecture&lt;/a&gt;, they could be summarised into:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prevent having the whole browser crash if one of the tabs become unresponsive (e.g. rendering engine crashes) this wonâ€™t affect the browser or other running web apps. &lt;/li&gt;
&lt;li&gt;To take advantage of the modern computer architectures by parallelizing the execution of the rendering engines for each tab along with the rest of web apps and extensions. &lt;/li&gt;
&lt;li&gt;Provide a sandbox for tabs, web apps, etc. to limit the damage if an exploit occurs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Soon enough, other flagship browsers have started to follow this model including Mozilla's Firefox in a project named &lt;a href="https://wiki.mozilla.org/Content_Processes"&gt;Electrolysis&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;In the next post, we'll start our journey to explore the concurrency realm in C++11 from managing threads, synchronizing operations between threads and protecting shared data.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4&gt;Further reading&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Operating-Systems-Internals-Principles-Edition/dp/013230998X"&gt;William Stalling's - Operating Systems: Internals and Design Principles&lt;/a&gt; (Part 2 - Processes)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.haskell.org/haskellwiki/Parallelism_vs._Concurrency"&gt;On parallelism vs. concurrency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><category>Concurrency</category><guid>http://amrelroumy.github.io/posts/2013/06/concurrency-in-cpp-prologue.html</guid><pubDate>Tue, 11 Jun 2013 09:00:00 GMT</pubDate></item></channel></rss>